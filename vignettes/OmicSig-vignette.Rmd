---
title: "OmicSig-vignette"
output: rmarkdown::html_vignette
author: "Vanessa Mengze Li"
date: "Aug 12th 2020"
vignette: >
  %\VignetteIndexEntry{OmicSig-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Load our library first! If you haven't installed `SigRepoR` yet, please contact vmli@bu.edu for instruction.
```{r message=FALSE, warning=FALSE}
devtools::document()
library(SigRepoR)
library(dplyr)
```

## Create an OmicSignature Object 
An `OmicSignature` object contains three parts:  
 - **metadata**, a list contains metadata fields;  
 - **signature**, a dataframe with feature symbols and directions, and scores if applicable;  
 - **difexp**, optional, a dataframe from differential expression analysis result.  

The example provided below is from an experiment for Myc gene reduce in mice. 
Signatures was extracted by comparing the liver of treatment and control when 
mice is 24-month old. This is a bi-directional signature example, which contains 
up and down regulated features (genes).

### Specify metadata
To be saved into a OmicSignature object, the required **metadata** fields are:  
**"signature_name", "organism", "platform", "direction_type", "phenotype"**.  
We can also specify other criterias such as fdr and log fold change cutoff of 
the signature, and provide key words of our experiment to make the description 
more complete.
One option is to create metadata list by hand, similar as follows:
```
metadata <- list(
  "signature_name" = Myc_reduce_mice_liver_24m,
  "organism" = "Mus Musculus",
  "sample_type" = "C57BL/6",
  "phenotype" = "Myc_reduce",
  "direction_type" = "bi-directional",
  "platform" = "GPL6246",
  "fdr_cutoff" = 0.05,
  "score_cutoff" = 7,
  "keywords" = c("Myc", "KO", "longevity"),
  "PMID" = 25619689,
  "year" = 2015
)
```
Or use our build-in function `createMetadata` (recommended):
```{r}
metadata <- createMetadata(
  signature_name = "Myc_reduce_mice_liver_24m",
  organism = "Mus Musculus",
  sample_type = "C57BL/6",
  phenotype = "Myc_reduce",
  direction_type = "bi-directional",
  platform = "GPL6246",
  fdr_cutoff = 0.05,
  score_cutoff = 7,
  keywords = c("Myc", "KO", "longevity"),
  PMID = 25619689,
  year = 2015)
```

If "sample_type" is not a BRENDA ontology name or "platform" is not a valid GEO platform accession ID, you will receive warnings when creating the OmicSignature object. See more info about these two fields below.

#### Additional info for "sample_type" and "platform"
In this example, the sample_type is a mouse strain and not a BRENDA tissue ontology term. But if your signature was generated from a specific cell or tissue, we highly recommended you to **specify the cell or tissue name using the standard BRENDA ontology term**. e.g. "SUM-149PT cell", and not "SUM 149 PT".  
You can find the correct ontology term to use by `BRENDASearch()` function.  
For example, search for ontology terms contain "SUM" and "cell":
```{r}
BRENDASearch("SUM cell") 
```

In addition, we use GEO platform accession ID, e.g. "GPL6246", in our *SigRepo database*. If you are not sure about your GEO platform accession ID, you can search by using function `GEOPlatformSearch()`.  
For example, search for platform names contains “illumina” and species name contains "homo":
```{r}
GEOPlatformSearch("illumina", species = "homo")
```


### Read in a matrix of differential expression analysis result
The differential expression analysis in this example was performed using a standard 
pipeline from lm package. Available columns are logFC, AveExpr, t score, P.Value, 
adj.P.Val, B score, Probe.ID, gene_symbol and gene_name.
```{r}
difexp <- read.table(file = "difmatrix_Myc_mice_liver_24m_raw.txt", 
    header = TRUE, sep="\t", stringsAsFactors = FALSE)
head(difexp)
```
To be saved into a OmicSignature object, the required columns for
**differential expression matrix** are:  
**"probe_id", "symbol", "score", "p_value", "fdr"**.  

Modify the column names to match the requirement.  
Our build-in function `replaceDifexpCol()` is designed to replace some 
frequently-used alternative column names. You can also change the column names manully.
```{r}
colnames(difexp) <- replaceDifexpCol(colnames(difexp))
head(difexp)
```


### Create signature
This is a bi-directional signature example. It contains up and down regulated 
genes.  
There are multiple ways to get signatures from a differential expression 
analysis matrix. One way is to use `filter()` from `dplyr` package.

```{r}
temp_upsig <- cbind(
  filter(difexp, score > metadata$score_cutoff & fdr < metadata$fdr_cutoff) %>% pull(symbol),
  filter(difexp, score > metadata$score_cutoff & fdr < metadata$fdr_cutoff) %>% pull(score),
  "+"
)
head(temp_upsig)

temp_dnsig <- cbind(
  dplyr::filter(difexp, score < (-1)*metadata$score_cutoff & fdr < metadata$fdr_cutoff) %>% pull(symbol),
  dplyr::filter(difexp, score < (-1)*metadata$score_cutoff & fdr < metadata$fdr_cutoff) %>% pull(score),
  "-"
)
head(temp_dnsig)
```
(note: if you see numbers instead of gene symbol name in the first column, please check if the "symbol" column in your difexp matrix is "character" and not accidentally be "factor")  


The **signature** need to be a **dataframe** with column **"signature_symbol"**.  
If the signature is "bi-directional" or "multi-directional" (specified in 
`direction_type` in `metadata` list), then column **"signature_direction"** is 
also required. "uni-directional" type does not require this column.  
An **optional column "signature_score"** is used when feature scores are available.  

```{r}
signatures <- data.frame(rbind(temp_upsig, temp_dnsig))
colnames(signatures) <- c("signature_symbol", "signature_score", "signature_direction")
```

Our function `standardezeSigDF()` can help you to remove duplicate rows, empty symbols in the signature dataframe, if any.
```{r}
signatures <- standardezeSigDF(signatures)
head(signatures)
tail(signatures)
```


### Create OmicSignature object
We have everything we need now.  
Use `OmicSignature$new()` to create a new OmicSignature R6 object.  
```{r}
OmicObj <- OmicSignature$new(
  metadata = metadata,
  signature = signatures,
  difexp = difexp
)
```

Use `print()` to see its information:
```{r}
print(OmicObj)
```

You can also ask the program to print the messages while creating the 
OmicSignature Object. By default, `print_message` is set to be `FALSE`.
```{r}
OmicObj <- OmicSignature$new(
  metadata = metadata,
  signature = signatures,
  difexp = difexp,
  print_message = TRUE
)
```

### Extract new signatures from the `OmicSignature` object
Previously we created the signature using abs(logfc) > 1 and fdr < 0.005.
Now we can use new criterias to extract new signatures conveniently from 
the OmicSignature Object.  
For example, extract all features with a t-score with absolute value 
higher than 20 and fdr less than 0.001:
```{r}
OmicObj$extract.signature("abs(score) > 20; fdr < 0.001")
```

## Write OmicSignature Object into a .json file
Besides save the OmicSignature object as an `.rds` file, we can also save it as 
a `.json` text file:
```
writeJson(OmicObj, "Myc_reduce_mice_liver_24m.json")
```

We can also read in a OmicSignature object from a `.json` file.  
The following example OmicSignature objects were generated from Sum149 cell line 
with AhR and CYP1B1 gene KO.  
```{r}
OmicObjSum149AhR <- readJson("Sum149_AhR_obj.json")
OmicObjSum149CYP1B1 <- readJson("Sum149_CYP1B1_obj.json")
```

## Create an OmicSignatureCollection Object
We have two OmicSignature objects: "Sum149_CYP1B1" and "Sum149_AhR".  
An `OmicSignatureCollection` object contains two parts:  
 - metadata  
 - OmicSigList, for a list of OmicSignature Objects  

### Specify metadata for the collection
The required fields for **metadata** are:  
**"collection_name", "description"**. We can also add additional 
fields.  
```{r}
ColMeta <- list(
  "collection_name" = "Sum149_collection",
  "description" = "A collection for Sum149 gene KO",
  "organism" = "Homo Sapiens",
  "author" = "me"
)
```

Create an `OmicSignatureCollection` object.  
Use `OmicSignatureCollection$new()` and provide our metadata and a list of 
`OmicSignature` objects: 
```{r}
OmicCol <- OmicSignatureCollection$new(
  OmicSigList = list(OmicObjSum149AhR, OmicObjSum149CYP1B1),
  metadata = ColMeta,
  print_message = FALSE
)
```
By default, `print_message` is set to `FALSE`. You can change it to `TRUE` to 
see the messages. During the creation of OmicSignatureCollection object, all 
input `OmicSignature` objects will be re-created to make sure they are all valid.  

### Extract new signatures from the `OmicSignatureCollection` object
We can extract new signatures from the `OmicSignatureCollection` object using 
new criterias.  
By default, the features are ranked by score.  
By default, `bind` is set to be `TRUE` to output results from all *OmicSignature* 
objects as a single dataframe.  
```{r}
OmicCol$extract.signature("score < -25; fdr < 0.005", bind = TRUE)
```

If `bind` is set to be `FALSE`, the output of each *OmicSignature* objects are 
provided individually as one element in a list.
```{r}
OmicCol$extract.signature("score < -25; fdr < 0.005", bind = FALSE)
```


Thank you! Please contact vmli@bu.edu if you have any questions.

--
